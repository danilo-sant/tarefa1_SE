#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h" 
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/adc.h"
#include "hardware/i2c.h"
#include <stdio.h>
#include <string.h>

#include "inc/ssd1306.h"
#include "inc/ssd1306_font.h"

// --- Constantes ---
#define LED_PIN 12
#define JOYSTICK_X_ADC_CH   1
#define JOYSTICK_Y_ADC_CH   0
#define JOYSTICK_X_GPIO     27
#define JOYSTICK_Y_GPIO     26
#define JOYSTICK_THRESHOLD_HIGH 3000
#define JOYSTICK_THRESHOLD_LOW  1000
#define JOYSTICK_REPORT_INTERVAL_MS 500 
#define TEMPERATURE_SAMPLES_FOR_AVERAGE 3
#define SPLASH_SCREEN_DELAY_MS 3000 // Define o tempo da splash screen em 3 segundos

// --- DADOS DO BITMAP DO LOGO (Copiado do seu arquivo display_oled (1).c) ---
const uint8_t logo_bitmap[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x40, 0x00, 0x20, 0x00, 0x10, 0x00, 0x00, 0x08, 0x00, 
	0x40, 0x00, 0x08, 0x40, 0x00, 0x00, 0x28, 0x00, 0x10, 0x00, 0x04, 0x00, 0x20, 0x04, 0x80, 0x00, 
	0x24, 0x00, 0x00, 0x24, 0x00, 0x00, 0x04, 0x20, 0x00, 0x04, 0x20, 0x80, 0x08, 0x22, 0x00, 0x10, 
	0x00, 0x84, 0x00, 0x10, 0x04, 0x40, 0x00, 0x12, 0x40, 0x04, 0x50, 0x02, 0x20, 0x00, 0x04, 0x00, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0x10, 0x00, 0x82, 0x00, 0x40, 0x08, 0x00, 0x00, 0x10, 0x00, 0x04, 0x00, 0x41, 0x00, 
	0x08, 0x80, 0x00, 0x12, 0x00, 0x40, 0x02, 0xe8, 0xc0, 0x01, 0x08, 0xe0, 0xc1, 0x00, 0x40, 0xc8, 
	0xe0, 0x02, 0x00, 0xd0, 0xc1, 0x40, 0x08, 0x41, 0xe0, 0x88, 0x02, 0x20, 0x88, 0x01, 0x24, 0x00, 
	0x80, 0x08, 0x22, 0x00, 0x11, 0x00, 0x44, 0x00, 0x11, 0x44, 0x00, 0x91, 0x04, 0x00, 0x91, 0x00, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x04, 0x21, 0x80, 0x08, 0x20, 0x80, 0x08, 0x20, 0x80, 0x01, 0x48, 0x00, 0x44, 0x80, 0xc2, 
	0xc0, 0xc0, 0xe8, 0xfe, 0xfc, 0xfd, 0xfc, 0x3f, 0x3f, 0x3c, 0x3e, 0x3f, 0x3f, 0x3c, 0x3c, 0xbf, 
	0x3f, 0x3e, 0x3c, 0xbf, 0x3f, 0x3e, 0x3c, 0xbd, 0x3f, 0x7e, 0xfc, 0xfe, 0xfc, 0xfc, 0xc1, 0xc0, 
	0xe0, 0x84, 0x00, 0x29, 0x00, 0x82, 0x08, 0x21, 0x00, 0x08, 0x42, 0x10, 0x00, 0x04, 0x20, 0x00, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x01, 0xa8, 0x00, 0x44, 0x00, 0x10, 0x42, 0x10, 0x00, 0x44, 0x10, 0x02, 0x48, 0x88, 0xdd, 
	0x88, 0xdc, 0x9a, 0xff, 0xff, 0xff, 0xef, 0x80, 0xe0, 0xd5, 0xe0, 0x90, 0xc5, 0xf8, 0xfc, 0xfe, 
	0x8e, 0xce, 0x8e, 0xce, 0xbe, 0xfc, 0xf8, 0xc0, 0x00, 0xb7, 0xff, 0xff, 0xff, 0xff, 0x88, 0xdc, 
	0x88, 0x9a, 0x40, 0x01, 0x08, 0x80, 0x24, 0x00, 0x11, 0x00, 0x44, 0x00, 0x11, 0x00, 0x04, 0x00, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x44, 0x00, 0x10, 0x42, 0x00, 0x29, 0x00, 0x88, 0x01, 0x20, 0x04, 0x11, 0x00, 0x98, 0x9d, 
	0x99, 0x9d, 0xd9, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x01, 0x93, 0x01, 0x09, 0x41, 0x0f, 0x1f, 0x3d, 
	0x39, 0x31, 0x39, 0x31, 0x39, 0x1d, 0x19, 0x01, 0x00, 0xaa, 0xff, 0xff, 0xff, 0xff, 0x99, 0x99, 
	0x99, 0x99, 0x00, 0x44, 0x00, 0x08, 0x00, 0x42, 0x00, 0x10, 0x02, 0x00, 0x20, 0x01, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0x20, 0x02, 0x10, 0x01, 0x40, 0x04, 0x10, 0x00, 0x04, 0x21, 0x00, 0x94, 0x01, 0x41, 
	0x05, 0x91, 0x05, 0x3f, 0x1f, 0x5f, 0x9f, 0xfe, 0xfe, 0x1e, 0x5e, 0xfe, 0xfe, 0x1e, 0x9f, 0xfe, 
	0xfe, 0x9e, 0x1f, 0xfe, 0xfe, 0x9e, 0x1e, 0x5e, 0xfe, 0x5f, 0x1f, 0x1f, 0x1f, 0x1f, 0x01, 0x01, 
	0x01, 0x01, 0x10, 0x00, 0x00, 0x00, 0x80, 0x04, 0x40, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0x00, 0x10, 0x02, 0x00, 0x08, 0x41, 0x00, 0x20, 0x09, 0x00, 0x04, 0x20, 0x02, 0x90, 
	0x00, 0x04, 0x10, 0x41, 0x04, 0x10, 0x42, 0x09, 0x23, 0x00, 0xa8, 0x03, 0x09, 0xa2, 0x08, 0x41, 
	0x13, 0x24, 0x80, 0x29, 0x03, 0xa8, 0x02, 0x91, 0x0b, 0xa1, 0x08, 0x52, 0x00, 0x25, 0x48, 0x00, 
	0x54, 0x00, 0x52, 0x00, 0x50, 0x80, 0x10, 0xa0, 0x00, 0x20, 0x40, 0x00, 0x40, 0x80, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x08, 0x00, 0x00, 0x42, 0x00, 0x11, 0x00, 0x00, 0x92, 0x00, 
	0x00, 0x49, 0x00, 0x04, 0x21, 0x00, 0x94, 0x01, 0x20, 0x02, 0x88, 0x22, 0x00, 0x14, 0x40, 0x05, 
	0x10, 0x42, 0x08, 0x22, 0x80, 0x08, 0x22, 0x90, 0x04, 0x22, 0x08, 0x41, 0x14, 0x41, 0x04, 0x91, 
	0x24, 0x01, 0x54, 0x01, 0x48, 0x12, 0x00, 0x54, 0x01, 0x94, 0x01, 0xaa, 0x00, 0x14, 0x41, 0x08, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// Enum para o Joystick
typedef enum {
    DIR_CENTER, DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT
} JoystickDirection;

// --- RECURSOS GLOBAIS PARA O DISPLAY ---
SemaphoreHandle_t display_mutex; 
uint8_t screen_buffer[ssd1306_buffer_length];
struct render_area frame_area;

// --- Funções de Hardware e Configuração ---
void display_setup() {
    i2c_init(i2c1, ssd1306_i2c_clock * 1000);
    gpio_set_function(14, GPIO_FUNC_I2C);
    gpio_set_function(15, GPIO_FUNC_I2C);
    gpio_pull_up(14);
    gpio_pull_up(15);
    ssd1306_init();
    frame_area.start_column = 0;
    frame_area.end_column = ssd1306_width - 1;
    frame_area.start_page = 0;
    frame_area.end_page = ssd1306_n_pages - 1;
    calculate_render_area_buffer_length(&frame_area);
    memset(screen_buffer, 0, ssd1306_buffer_length);
    render_on_display(screen_buffer, &frame_area);
}

void setup(void) {
    stdio_init_all();
    adc_init();
    adc_set_temp_sensor_enabled(true);
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);
    adc_gpio_init(JOYSTICK_X_GPIO);
    adc_gpio_init(JOYSTICK_Y_GPIO);
    display_setup();
}

float read_onboard_temperature() {
    const float conversion_factor = 3.3f / (1 << 12);
    adc_select_input(4);
    uint16_t raw_value = adc_read();
    float voltage = raw_value * conversion_factor;
    return 27.0f - (voltage - 0.706f) / 0.001721f;
}

// --- Tarefas (Tasks) ---
void vTemperatureTask(void *pvParameters) {
    static uint cnt = 0;
    static float avg_temp_sum = 0;
    char temp_str[20];

    for (;;) {
        avg_temp_sum += read_onboard_temperature();
        cnt++;
        if (cnt >= TEMPERATURE_SAMPLES_FOR_AVERAGE) {
            float average = avg_temp_sum / TEMPERATURE_SAMPLES_FOR_AVERAGE;
            if (xSemaphoreTake(display_mutex, portMAX_DELAY) == pdTRUE) {
                snprintf(temp_str, sizeof(temp_str), "Temp: %.1f C", average);
                ssd1306_draw_string(screen_buffer, 0, 0, "            ");
                ssd1306_draw_string(screen_buffer, 0, 0, temp_str);
                render_on_display(screen_buffer, &frame_area);
                xSemaphoreGive(display_mutex);
            }
            cnt = 0;
            avg_temp_sum = 0;
        }
        vTaskDelay(pdMS_TO_TICKS(2000));
    }
}

void vJoystickTask(void *pvParameters) {
    JoystickDirection current_direction = DIR_CENTER;
    JoystickDirection last_reported_direction = DIR_CENTER;
    TickType_t last_print_timestamp = 0;
    char joy_str[20]; 

    for (;;) {
        adc_select_input(JOYSTICK_Y_ADC_CH);
        uint16_t adc_y = adc_read();
        adc_select_input(JOYSTICK_X_ADC_CH);
        uint16_t adc_x = adc_read();

        if (adc_y > JOYSTICK_THRESHOLD_HIGH) current_direction = DIR_UP;
        else if (adc_y < JOYSTICK_THRESHOLD_LOW) current_direction = DIR_DOWN;
        else if (adc_x > JOYSTICK_THRESHOLD_HIGH) current_direction = DIR_RIGHT;
        else if (adc_x < JOYSTICK_THRESHOLD_LOW) current_direction = DIR_LEFT;
        else current_direction = DIR_CENTER;

        if (current_direction != last_reported_direction) {
            last_reported_direction = current_direction;
            TickType_t current_tick = xTaskGetTickCount();
            if ((current_tick - last_print_timestamp) > pdMS_TO_TICKS(JOYSTICK_REPORT_INTERVAL_MS)) {
                if (current_direction != DIR_CENTER) {
                    const char* dir_str;
                    switch (current_direction) {
                        case DIR_UP:    dir_str = "Cima";     break;
                        case DIR_DOWN:  dir_str = "Baixo";    break;
                        case DIR_LEFT:  dir_str = "Esquerda"; break;
                        case DIR_RIGHT: dir_str = "Direita";  break;
                        default:        dir_str = "N/A";      break;
                    }
                    if (xSemaphoreTake(display_mutex, portMAX_DELAY) == pdTRUE) {
                        snprintf(joy_str, sizeof(joy_str), "Joy: %s", dir_str);
                        ssd1306_draw_string(screen_buffer, 0, 16, "               ");
                        ssd1306_draw_string(screen_buffer, 0, 16, joy_str);
                        render_on_display(screen_buffer, &frame_area);
                        xSemaphoreGive(display_mutex);
                    }
                    last_print_timestamp = current_tick;
                }
            }
        }
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

void vBlinkTask(void *pvParameters) {
    for (;;) {
        gpio_put(LED_PIN, 1);
        vTaskDelay(pdMS_TO_TICKS(50));
        gpio_put(LED_PIN, 0);
        vTaskDelay(pdMS_TO_TICKS(950));
    }
}

// --- Função Principal ---
int main() {
    setup();
    
    // --- LÓGICA DA SPLASH SCREEN ---
    // Este bloco é executado ANTES do FreeRTOS iniciar.
    
    // 1. Copia os dados do bitmap para o nosso buffer de tela global
    memcpy(screen_buffer, logo_bitmap, sizeof(logo_bitmap));
    
    // 2. Renderiza o buffer (com o logo) no display
    render_on_display(screen_buffer, &frame_area);
    
    // 3. Mantém o logo na tela por 3 segundos
    sleep_ms(SPLASH_SCREEN_DELAY_MS);
    
    // 4. Limpa o buffer e o display para preparar para a tela de dados
    memset(screen_buffer, 0, ssd1306_buffer_length);
    render_on_display(screen_buffer, &frame_area);
    // --- FIM DA LÓGICA DA SPLASH SCREEN ---
    
    display_mutex = xSemaphoreCreateMutex();

    if (display_mutex != NULL) {
        xTaskCreate(vTemperatureTask, "Temp Task", configMINIMAL_STACK_SIZE * 4, NULL, 1, NULL);
        xTaskCreate(vJoystickTask, "Joystick Task", configMINIMAL_STACK_SIZE * 4, NULL, 1, NULL);
        xTaskCreate(vBlinkTask, "Blink Task", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
        vTaskStartScheduler();
    }
    
    while (1);
    return 0;
}